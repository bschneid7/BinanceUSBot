/**
 * Metrics Service
 * Collects and exposes Prometheus-compatible metrics for Grafana
 */

import { Request, Response } from 'express';

interface MetricValue {
  value: number;
  timestamp: number;
  labels?: Record<string, string>;
}

interface Metric {
  name: string;
  type: 'counter' | 'gauge' | 'histogram';
  help: string;
  values: Map<string, MetricValue>;
}

class MetricsService {
  private static instance: MetricsService;
  private metrics: Map<string, Metric>;
  private startTime: number;

  private constructor() {
    this.metrics = new Map();
    this.startTime = Date.now();
    this.initializeMetrics();
  }

  static getInstance(): MetricsService {
    if (!MetricsService.instance) {
      MetricsService.instance = new MetricsService();
    }
    return MetricsService.instance;
  }

  private initializeMetrics(): void {
    // Trading metrics
    this.registerMetric('trading_signals_total', 'counter', 'Total number of trading signals generated');
    this.registerMetric('trading_orders_total', 'counter', 'Total number of orders placed');
    this.registerMetric('trading_orders_filled', 'counter', 'Total number of orders filled');
    this.registerMetric('trading_orders_failed', 'counter', 'Total number of failed orders');
    this.registerMetric('trading_pnl_total', 'gauge', 'Total profit/loss in USD');
    this.registerMetric('trading_pnl_daily', 'gauge', 'Daily profit/loss in USD');
    this.registerMetric('trading_pnl_weekly', 'gauge', 'Weekly profit/loss in USD');
    this.registerMetric('trading_equity', 'gauge', 'Current account equity in USD');
    this.registerMetric('trading_positions_open', 'gauge', 'Number of open positions');
    this.registerMetric('trading_win_rate', 'gauge', 'Win rate percentage');
    
    // Performance metrics
    this.registerMetric('api_requests_total', 'counter', 'Total number of API requests');
    this.registerMetric('api_requests_failed', 'counter', 'Total number of failed API requests');
    this.registerMetric('api_rate_limit_hits', 'counter', 'Number of times rate limit was hit');
    this.registerMetric('websocket_reconnections', 'counter', 'Number of WebSocket reconnections');
    this.registerMetric('websocket_connected', 'gauge', 'WebSocket connection status (1=connected, 0=disconnected)');
    
    // System metrics
    this.registerMetric('bot_uptime_seconds', 'gauge', 'Bot uptime in seconds');
    this.registerMetric('bot_health', 'gauge', 'Bot health status (1=healthy, 0=unhealthy)');
    this.registerMetric('kill_switch_active', 'gauge', 'Kill switch status (1=active, 0=inactive)');
    
    // Strategy metrics
    this.registerMetric('strategy_confidence_avg', 'gauge', 'Average strategy confidence score');
    this.registerMetric('strategy_signals_by_tier', 'counter', 'Signals generated by tier');
  }

  private registerMetric(name: string, type: Metric['type'], help: string): void {
    this.metrics.set(name, {
      name,
      type,
      help,
      values: new Map()
    });
  }

  private getLabelKey(labels?: Record<string, string>): string {
    if (!labels) return 'default';
    return Object.entries(labels)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([k, v]) => `${k}="${v}"`)
      .join(',');
  }

  /**
   * Increment a counter metric
   */
  incrementCounter(name: string, value: number = 1, labels?: Record<string, string>): void {
    const metric = this.metrics.get(name);
    if (!metric || metric.type !== 'counter') return;

    const labelKey = this.getLabelKey(labels);
    const current = metric.values.get(labelKey);
    
    metric.values.set(labelKey, {
      value: (current?.value || 0) + value,
      timestamp: Date.now(),
      labels
    });
  }

  /**
   * Set a gauge metric value
   */
  setGauge(name: string, value: number, labels?: Record<string, string>): void {
    const metric = this.metrics.get(name);
    if (!metric || metric.type !== 'gauge') return;

    const labelKey = this.getLabelKey(labels);
    metric.values.set(labelKey, {
      value,
      timestamp: Date.now(),
      labels
    });
  }

  /**
   * Get current value of a metric
   */
  getValue(name: string, labels?: Record<string, string>): number | undefined {
    const metric = this.metrics.get(name);
    if (!metric) return undefined;

    const labelKey = this.getLabelKey(labels);
    return metric.values.get(labelKey)?.value;
  }

  /**
   * Update bot uptime
   */
  updateUptime(): void {
    const uptimeSeconds = Math.floor((Date.now() - this.startTime) / 1000);
    this.setGauge('bot_uptime_seconds', uptimeSeconds);
  }

  /**
   * Export metrics in Prometheus format
   */
  exportPrometheusMetrics(): string {
    this.updateUptime(); // Update uptime before export

    const lines: string[] = [];

    for (const metric of this.metrics.values()) {
      // Add HELP line
      lines.push(`# HELP ${metric.name} ${metric.help}`);
      // Add TYPE line
      lines.push(`# TYPE ${metric.name} ${metric.type}`);
      
      // Add metric values
      for (const [labelKey, metricValue] of metric.values.entries()) {
        if (labelKey === 'default') {
          lines.push(`${metric.name} ${metricValue.value}`);
        } else {
          lines.push(`${metric.name}{${labelKey}} ${metricValue.value}`);
        }
      }
      
      lines.push(''); // Empty line between metrics
    }

    return lines.join('\n');
  }

  /**
   * Export metrics as JSON
   */
  exportJSON(): Record<string, any> {
    this.updateUptime();

    const result: Record<string, any> = {};

    for (const metric of this.metrics.values()) {
      const metricData: any = {
        type: metric.type,
        help: metric.help,
        values: []
      };

      for (const [labelKey, metricValue] of metric.values.entries()) {
        metricData.values.push({
          labels: metricValue.labels || {},
          value: metricValue.value,
          timestamp: metricValue.timestamp
        });
      }

      result[metric.name] = metricData;
    }

    return result;
  }

  /**
   * Express middleware to expose /metrics endpoint
   */
  metricsEndpoint(req: Request, res: Response): void {
    const format = req.query.format as string;
    
    if (format === 'json') {
      res.setHeader('Content-Type', 'application/json');
      res.send(JSON.stringify(this.exportJSON(), null, 2));
    } else {
      res.setHeader('Content-Type', 'text/plain; version=0.0.4');
      res.send(this.exportPrometheusMetrics());
    }
  }

  /**
   * Reset all metrics (useful for testing)
   */
  reset(): void {
    for (const metric of this.metrics.values()) {
      metric.values.clear();
    }
    this.startTime = Date.now();
  }
}

export const metricsService = MetricsService.getInstance();
